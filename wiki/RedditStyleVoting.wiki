#summary Implementing reddit style voting for any Model with django-voting
#labels Featured

= Reddit Style Voting =

A quick guide to implementing those famous [http://programming.reddit.com reddit] up and down voting arrows which cast or clear your votes, using django-voting.

== Template ==

We'll assume that you're going to render a list of items where you don't have access to the list in your view function, as would happen if you were using the `object_list` generic view to page through items. In this case, you can use the `voting_tags` template library supplied with django-voting to do all the hard work.

In this particular example, we're dealing with a list of `Link` objects, contained in the context variable `link_list`. As django-voting uses generic views, you could do this for _any_ list of instances of _any_ `Model` in your application.

First, we want to load existing votes the current user has made on each `Link` in the list, as we'll need this information to set up the initial state of our voting widgets and forms.

{{{
{% load voting_tags %}
{% votes_by_user user link_list as vote_dict %}
}}}

We'll display our list of links in a basic table:

{{{
<table>
<col width="1"></col>
<col></col>
<thead>
  <tr>
    <th>Vote</th>
    <th>Link</th>
  </tr>
</thead>
<tbody>
  {% for link in link_list %}<tr class="{% cycle odd,even %}">
    <td class="vote">
}}}

So far, so easy - but now we want to set up the arrow widgets for voting on the the current `Link`.

We'll start by getting the vote made for the current `Link` from the votes we loaded earlier:

{{{
      {% vote_for_item link from vote_dict as vote %}
}}}

`Vote` objects have `is_upvote` and `is_downvote` methods which we can use to check which direction the user voted in for the current `Link`. We guard against the user not having voted yet by first checking for the existence of the `vote` context variable.

In this implementation, each voting arrow will get its own form, with the `action` attribute determining the kind of vote which will be cast when the form is submitted. For the arrow voting widget in each form, an `input type="image"` is used. We'll `POST` the forms for simplicity's sake, so there won't be a vote confirmation screen.

If the user has already voted in either direction, the arrow image displayed should indicate this and submitting the form should clear the user's vote:

{{{
      <form class="vote" id="up{{ link.id }}" action="{{ link.id }}/{% if vote and vote.is_upvote %}clear{% else %}up{% endif %}vote/" method="POST">
        <input type="image" id="uparrow{{ link.id }}" src="{{ media_url }}img/aup{% if vote and vote.is_upvote %}mod{% else %}grey{% endif %}.png">
      </form>

      <form class="vote" id="down{{ link.id }}" action="{{ link.id }}/{% if vote and vote.is_downvote %}clear{% else %}down{% endif %}vote/" method="POST">
        <input type="image" id="downarrow{{ link.id }}" src="{{ media_url }}img/adown{% if vote and vote.is_downvote %}mod{% else %}grey{% endif %}.png">
      </form>
}}}

We'll finish  off by displaying the Link itself.

{{{
    </td>
    <td class="item">
      <a href="{{ link.url }}">{{ link.title|escape }}</a></h2>
      <p class="details">
        posted <span class="created">{{ link.created|timesince }} ago by {{ link.user.get_full_name|escape }}
      </p>
    </td>
  </tr>{% endfor %}
</tbody>
</table>
}}}

== Progressive Enhancement ==

You may have noticed the `class` attribute on the voting forms and the `id` attributes on the voting forms and widgets - these will allow us to [http://domscripting.com/blog/display/41 progressively enhance] the voting process using XMLHttpRequest.

When you're using the `voting.views.vote_on_object` view, you can enable fall-_forward_ to processing and responding to the request in a manner suitable for an XMLHttpRequest by passing in `allow_xmlhttprequest=True` when setting up the view.

Assuming we've configured the voting view this way, we can use JavaScript when the page loads to hijack the voting forms, cancelling the default form submission, sending the request via XMLHttpRequest instead and processing the JSON response we're given, which involves updating the voting forms and widgets to reflect the vote which was made when it was successfully processed.

For this example, we'll use the [http://www.prototypejs.org/ Prototype library], version 1.5.1 RC1, purely because it already sets the `HTTP_X_REQUESTED_WITH` header the `voting.views.vote_on_object` view looks for to determine if a request was made using XMLHttpRequest. That and I want to see what's changed since version 1.3.1.

All that said, here's the 10 minute quick and dirty script for progressively enhancing voting - simply dropping this script into the page will result in all voting being done via XMLHttpRequest, with voting arrows and form actions updated appropriately after votes have been made:

{{{
function doVote(e)
{
    Event.stop(e);
    var form = Event.element(e);
    var id = /(\d+)$/.exec(form.id)[1];
    var action = /(up|down|clear)vote/.exec(form.action)[1];
    new Ajax.Request(form.action, {
        onComplete: processVoteResponse(id, action)
    });
};

function processVoteResponse(id, action)
{
    return function(transport)
    {
        var response = transport.responseText.evalJSON();
        if (response.success === true)
        {
            var upArrowType = "grey";
            var upFormAction = "up";
            var downArrowType = "grey";
            var downFormAction = "down";

            if (action == "up")
            {
                var upArrowType = "mod";
                var upFormAction = "clear";
            }
            else if (action == "down")
            {
                var downArrowType = "mod";
                var downFormAction = "clear";
            }

            setArrow("up", id, upArrowType);
            setArrow("down", id, downArrowType);
            setFormAction("up", id, upFormAction);
            setFormAction("down", id, downFormAction);
        }
        else
        {
            alert("Error voting: " + response.error_message);
        }
    };
};

function setArrow(arrowType, id, state)
{
    var img = $(arrowType + "arrow" + id);
    var re = new RegExp("a" + arrowType + "(?:mod|grey)\\.png");
    img.src = img.src.replace(re, "a" + arrowType + state + ".png");
};

function setFormAction(formType, id, action)
{
    var form = $(formType + id);
    form.action = form.action.replace(/(?:up|down|clear)vote/, action + "vote");
};

Event.observe(window, "load", function()
{
    $$("form.vote").each(function(form)
    {
        Event.observe(form, "submit", doVote.bindAsEventListener(), false);
    });
}, false);
}}}
